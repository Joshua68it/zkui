A composer is responsible to initialize a component (or a component of tree) when ZK loader is composing a component. It is the controller in the MVC pattern, while the component is the view,which separate the code from the user interfaces.

h3. Creating a composer
Composers can be created with the create-composer target. For example try running the following command from the root of a Grails project:
{code}
grails create-composer window
{code}

The command will result in the creation of a composer at the location grails-app/composers/WindowComposer.groovy:
{code:groovy}
class WindowComposer {
    static transactional = true
    def afterCompose = {Component comp ->
        // initialize components here
    }
}
{code}
WindowComposer by default provide a @afterCompose@ closure to initialize components.

{note}
The create-composer command is merely for convenience and you can just as easily create composers using your favorite text editor or IDE
{note}

h3. Apply a composer
Each component Taglib has a @apply@ attitude,so you can place the composer here
{code:xml}
<z:window id="myWindowComposer" apply="package.WindowComposer">
    ...
</z:window>
{code}

In the WindowComposer side
{code}
def afterCompose = {Component comp ->
    assert comp.id=="myWindowComposer"
    assert (comp instanceof org.zkoss.zul.Window)
}
{code}

h3. Transactional
Like grails services,composer allow the enablement of transaction demarcation, which is essentially a declarative way of saying all methods within this composer are to be made transactional
All composers have transaction demarcation enabled by default - to disable it, simply set the transactional property to false

{note}
Strongly recommend that set the transactional property to false,unless the transactional code in composer is very simple,it would be best use grails' services or programmatic transactions with the withTransaction method.
{note}

h3. Auto-wired Component
If apply a @composer@ to a Component that implement a @IdSpace@ Interface,such as org.zkoss.zul.Window. The Component's children can be auto-wired to composer's fields

The following is an example. The onChange event received by Textbox @mytextbox@ will be forwarded to target Window @mywin@ as a new target event onChange_mytextbox and the Textbox component with id name "mytextbox" and Label with id name @mylabel@ are injected into the "mytextbox" and "mylabel" fields respectively(so you can use mytextbox and mylabel variable directly in onChange_mytextbox without problem).

Composer
{code}
class MyComposer{
    Textbox mytextbox
    Window self //embeded object, the supervised window "mywin"
    Page page //the ZK page
    Label mylabel

    def afterCompose = {Component comp ->
        assert mytextbox.id=="mytextbox"
        assert mylabel.id=="mylabel"
    }

    def onChange_mytextbox(Event event) {
        mylabel.setValue("You just entered: "+ mytextbox.getValue())
    }
}
{code}

View
{code:xml}
<z:window id="mywin" apply="MyComposer">
    <z:textbox id="mytextbox"/>
    <z:label id="mylabel"/>
</z:window>
{code}

h3. Redirects

Actions can be redirected using the redirect method present in all composers

The parameters of @redirect@ is same as controller's @redirect@

Composer
{code}
class MyComposer{
    Button mybutton

    def afterCompose = {Component comp ->

    }

    def onClick_mybutton(Event event) {
        redirect(controller: 'demo', action: 'index', id: 1)
    }
}
{code}

{note}
following code same as @onClick_button@ above

{code}
def afterCompose = {Component comp ->
    mybutton.addEventListener('onClick'){
        redirect(controller: 'demo', action: 'index', id: 1)
    }
}
{code}

{note}


View
{code:xml}
<z:window id="mywin" apply="MyComposer">
    <z:button label="mybutton"/>
</z:window>
{code}


h3. Data Binding

To uses Grails' underlying data binding capability,@zkui@ injection a @getParams@ method to [Component|http://www.zkoss.org/javadoc/latest/zk/org/zkoss/zk/ui/Component.html].

Domain Class
{code}
class Person {
    String firstName
    String lastName
    String fullName
    static constraints = {
    }
}
{code}

View
{code:xml}
<z:window id="mywin" apply="MyComposer">
    <z:textbox name="firstName"/>
    <z:textbox name="lastName"/>
    <z:textbox name="fullName"/>
    <z:button label="submit"/>
</z:window>
{code}

Composer
{code}
class MyComposer{
    Button submit
    def afterCompose = {Component mywin ->
        submit.addEventListener('onClick'){
            def person=new Person(mywin.params)
            ...
        }
    }
}
{code}

A @bindData@ method same as in @controller@ also provide to Composer

{code}
def p = new Person()
bindData(p, mywin.params)
{code}

h3. Unit Test
When use *grails create-composer* create a composer,a unit class that is a sub-class of ComposerUnitTestCase also created

It provides a @mockComposer@ methods for mocking zkui's  Selector,Builder and so on.

{code}
mockComposer(MyComposer)
def myComposer=new MyComposer
...
{code}
